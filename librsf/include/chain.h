/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_chain_h
#define _sf_chain_h


#include "_bool.h"
#include "_solver.h"


void sf_chain( sf_operator oper1     /* outer operator */, 
	       sf_operator oper2     /* inner operator */, 
	       bool adj              /* adjoint flag */, 
	       bool add              /* addition flag */, 
	       int nm                /* model size */, 
	       int nd                /* data size */, 
	       int nt                /* intermediate size */, 
	       /*@out@*/ float* mod  /* [nm] model */, 
	       /*@out@*/ float* dat  /* [nd] data */, 
	       float* tmp            /* [nt] intermediate */);
/*< Chains two operators, computing oper1{oper2{mod}} 
  or its adjoint. The tmp array is used for temporary storage. >*/


void sf_cchain( sf_coperator oper1         /* outer operator */, 
		sf_coperator oper2         /* inner operator */, 
		bool adj                   /* adjoint flag */, 
		bool add                   /* addition flag */, 
		int nm                     /* model size */, 
		int nd                     /* data size */, 
		int nt                     /* intermediate size */, 
		/*@out@*/ sf_complex* mod  /* [nm] model */, 
		/*@out@*/ sf_complex* dat  /* [nd] data */, 
		sf_complex* tmp            /* [nt] intermediate */);
/*< Chains two complex operators, computing oper1{oper2{mod}} 
  or its adjoint. The tmp array is used for temporary storage. >*/


void sf_array( sf_operator oper1     /* top operator */, 
	       sf_operator oper2     /* bottom operator */, 
	       bool adj              /* adjoint flag */, 
	       bool add              /* addition flag */, 
	       int nm                /* model size */, 
	       int nd1               /* top data size */, 
	       int nd2               /* bottom data size */, 
	       /*@out@*/ float* mod  /* [nm] model */, 
	       /*@out@*/ float* dat1 /* [nd1] top data */, 
	       /*@out@*/ float* dat2 /* [nd2] bottom data */);
/*< Constructs an array of two operators, 
  computing {oper1{mod},oper2{mod}} or its adjoint. >*/


void sf_carray( sf_coperator oper1     /* top operator */, 
	       sf_coperator oper2     /* bottom operator */, 
	       bool adj              /* adjoint flag */, 
	       bool add              /* addition flag */, 
	       int nm                /* model size */, 
	       int nd1               /* top data size */, 
	       int nd2               /* bottom data size */, 
	       /*@out@*/ sf_complex* mod  /* [nm] model */, 
	       /*@out@*/ sf_complex* dat1 /* [nd1] top data */, 
	       /*@out@*/ sf_complex* dat2 /* [nd2] bottom data */);
/*< Constructs an array of two complex operators, 
  computing {oper1{mod},oper2{mod}} or its adjoint. >*/


void sf_normal (sf_operator oper /* operator */, 
		bool add         /* addition flag */, 
		int nm           /* model size */, 
		int nd           /* data size */, 
		float *mod       /* [nd] model */, 
		float *dat       /* [nd] data */, 
		float *tmp       /* [nm] intermediate */);
/*< Applies a normal operator (self-adjoint) >*/


void sf_chain3 (sf_operator oper1 /* outer operator */, 
		sf_operator oper2 /* middle operator */, 
		sf_operator oper3 /* inner operator */, 
		bool adj          /* adjoint flag */, 
		bool add          /* addition flag */, 
		int nm            /* model size */, 
		int nt1           /* inner intermediate size */, 
		int nt2           /* outer intermediate size */, 
		int nd            /* data size */, 
		float* mod        /* [nm] model */, 
		float* dat        /* [nd] data */, 
		float* tmp1       /* [nt1] inner intermediate */, 
		float* tmp2       /* [nt2] outer intermediate */);
/*< Chains three operators, computing oper1{oper2{poer3{{mod}}} or its adjoint.
  The tmp1 and tmp2 arrays are used for temporary storage. >*/

#endif
