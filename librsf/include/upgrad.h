/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_upgrad_h
#define _sf_upgrad_h


typedef struct Sf_Upgrad *sf_upgrad;
/* abstract data type */


sf_upgrad sf_upgrad_init(int mdim        /* number of dimensions */,
			 const int *mm   /* [dim] data size */,
			 const float *d  /* [dim] data sampling */);
/*< initialize >*/


void sf_upgrad_set(sf_upgrad upg, const float *r0 /* reference */);
/*< supply reference >*/


void sf_upgrad_close(sf_upgrad upg);
/*< free allocated storage >*/


void sf_upgrad_solve(sf_upgrad upg,
		     const float *rhs /* right-hand side */, 
		     float *x         /* solution */,
		     const float *x0  /* initial solution */);
/*< inverse operator >*/


void sf_upgrad_inverse(sf_upgrad upg,
		       float *rhs       /* right-hand side */,
		       const float *x   /* solution */,
		       const float *x0  /* initial solution */);
/*< adjoint of inverse operator >*/


void sf_upgrad_forw(sf_upgrad upg,
		    const float *x /* solution */,
		    float *rhs     /* right-hand side */);
/*< forward operator >*/


void sf_upgrad_grad(sf_upgrad upg,
		    const float *x /* input */,
		    float **grad   /* gradient */);
/*< forward operator >*/


void sf_upgrad_adj(sf_upgrad upg,
		   float *x         /* solution */,
		   const float *rhs /* right-hand side */);
/*< adjoint operator >*/


void sf_upgrad_grad_adj(sf_upgrad upg,
			float *x     /* output */,
			float **grad /* gradient */);
/*< adjoint gradient operator >*/

#endif
